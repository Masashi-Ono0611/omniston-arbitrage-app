// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: omni/v1beta6/types/quote.proto

/* eslint-disable */
import {
  Address,
  SettlementMethod,
  settlementMethodFromJSON,
  settlementMethodToJSON,
} from "./common";
import { SwapRoute } from "./swap";

export const protobufPackage = "omni.v1beta6";

/**
 * Additional parameters of RFQ related to settlement.
 *
 * Some parameters might be valid only in a subset of settlement methods on a subset of supported blockchains.
 * These parameters might be omitted if corresponding settlement methods won't be used.
 */
export interface RequestSettlementParams {
  /** Max price slippage in basis points (0.01%). */
  maxPriceSlippageBps: number;
  /**
   * Max number of outgoing messages supported by the wallet.
   *
   * For TON blockchain defaults to 4 if omitted.
   */
  maxOutgoingMessages: number;
}

/** Settlement parameters specific to `SWAP` settlement method. */
export interface SwapSettlementParams {
  /** TODO: Add a separate destination for trade tracking and fee collection */
  routes: SwapRoute[];
}

/**
 * Settlement parameters specific to `ESCROW` settlement method.
 *
 * **UNSTABLE:** This is unstable API, it's subject to backward-incompatible changes.
 */
export interface EscrowSettlementParams {
  /** Address of escrow contract that enforces the swap. */
  contractAddress: Address | undefined;
  /** Address of the resolver. */
  resolverAddress: Address | undefined;
  /**
   * Duration in seconds after the deposit of offer asset to complete the trade.
   * The trader can return the deposit as soon as the timeout elapses.
   */
  resolveTimeout: number;
}

/**
 * Settlement parameters specific to `HTLC` settlement method.
 *
 * **UNSTABLE:** This is unstable API, it's subject to backward-incompatible changes.
 */
export interface HtlcSettlementParams {
  /** Address of htlc contract that enforces the swap. */
  contractAddress: Address | undefined;
  /** Address of the resolver. */
  resolverAddress: Address | undefined;
  /**
   * Duration in seconds after the deposit of offer asset to redeem the deposit by resolver.
   * The trader can return the deposit as soon as the timeout elapses.
   */
  resolveTimeout: number;
}

/** A request for quote (RFQ) sent by the trader */
export interface QuoteRequest {
  /** Blockchain-specific address of offer asset. */
  offerAssetAddress: Address | undefined;
  /** Blockchain-specific address of ask asset. */
  askAssetAddress: Address | undefined;
  amount: QuoteRequest_AmountOneOf | undefined;
  /** The address of referrer that will receive the fees. */
  referrerAddress: Address | undefined;
  /** The amount of fees required by the referrer in basis points (1/10000 or 0.01%) */
  referrerFeeBps: number;
  /**
   * Supported methods of swap settlement.
   * The protocol limits settlement methods in quotes to specified methods.
   * Different combinations of offer & ask chains might support different methods.
   */
  settlementMethods: SettlementMethod[];
  /** Additional parameters of request related to settlement. */
  settlementParams: RequestSettlementParams | undefined;
}

/** Either the amount of offer asset or ask asset. */
export interface QuoteRequest_AmountOneOf {
  /** The amount of offer asset the trader wants to pay, including all fees. */
  offerUnits?: string | undefined;
  /** The amount of ask asset the trader wants to get after all fees. */
  askUnits?: string | undefined;
}

export interface Quote {
  /** ID of the quote generated by the platform */
  quoteId: string;
  /** id of the resolver */
  resolverId: string;
  /** Name of the resolver */
  resolverName: string;
  /** Blockchain-specific address of offer asset. */
  offerAssetAddress: Address | undefined;
  /** Blockchain-specific address of ask asset. */
  askAssetAddress: Address | undefined;
  /** The amount of offer asset the trader must pay, including all fees. */
  offerUnits: string;
  /** The amount of ask asset the trader will get after all fees. */
  askUnits: string;
  /** The address of referrer that will receive the fees. */
  referrerAddress: Address | undefined;
  /** The amount of fees that the referrer will get (in units of `ask_asset_address`). */
  referrerFeeUnits: string;
  /** The amount of fees charged by the protocol (in units of `ask_asset_address`). */
  protocolFeeUnits: string;
  /** The timestamp (UTC seconds) of Quote sent by resolver. */
  quoteTimestamp: number;
  /**
   * Max timestamp (UTC seconds) of start of the trade.
   *
   * The start of the trade is defined as the reception of offer asset by the corresponding smart contract.
   * The resolver may still settle the trades started after this deadline has passed at own discretion.
   */
  tradeStartDeadline: number;
  /** Total gas budget required to perform the trade. */
  gasBudget: string;
  params: Quote_ParamsOneOf | undefined;
}

/** Additional parameters specific to settlement method. */
export interface Quote_ParamsOneOf {
  swap?: SwapSettlementParams | undefined;
  escrow?: EscrowSettlementParams | undefined;
  htlc?: HtlcSettlementParams | undefined;
}

function createBaseRequestSettlementParams(): RequestSettlementParams {
  return { maxPriceSlippageBps: 0, maxOutgoingMessages: 0 };
}

export const RequestSettlementParams = {
  fromJSON(object: any): RequestSettlementParams {
    return {
      maxPriceSlippageBps: isSet(object.max_price_slippage_bps)
        ? globalThis.Number(object.max_price_slippage_bps)
        : 0,
      maxOutgoingMessages: isSet(object.max_outgoing_messages)
        ? globalThis.Number(object.max_outgoing_messages)
        : 0,
    };
  },

  toJSON(message: RequestSettlementParams): unknown {
    const obj: any = {};
    if (message.maxPriceSlippageBps !== undefined) {
      obj.max_price_slippage_bps = Math.round(message.maxPriceSlippageBps);
    }
    if (message.maxOutgoingMessages !== undefined) {
      obj.max_outgoing_messages = Math.round(message.maxOutgoingMessages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestSettlementParams>, I>>(
    base?: I,
  ): RequestSettlementParams {
    return RequestSettlementParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestSettlementParams>, I>>(
    object: I,
  ): RequestSettlementParams {
    const message = createBaseRequestSettlementParams();
    message.maxPriceSlippageBps = object.maxPriceSlippageBps ?? 0;
    message.maxOutgoingMessages = object.maxOutgoingMessages ?? 0;
    return message;
  },
};

function createBaseSwapSettlementParams(): SwapSettlementParams {
  return { routes: [] };
}

export const SwapSettlementParams = {
  fromJSON(object: any): SwapSettlementParams {
    return {
      routes: globalThis.Array.isArray(object?.routes)
        ? object.routes.map((e: any) => SwapRoute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SwapSettlementParams): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => SwapRoute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapSettlementParams>, I>>(
    base?: I,
  ): SwapSettlementParams {
    return SwapSettlementParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapSettlementParams>, I>>(
    object: I,
  ): SwapSettlementParams {
    const message = createBaseSwapSettlementParams();
    message.routes = object.routes?.map((e) => SwapRoute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEscrowSettlementParams(): EscrowSettlementParams {
  return {
    contractAddress: undefined,
    resolverAddress: undefined,
    resolveTimeout: 0,
  };
}

export const EscrowSettlementParams = {
  fromJSON(object: any): EscrowSettlementParams {
    return {
      contractAddress: isSet(object.contract_address)
        ? Address.fromJSON(object.contract_address)
        : undefined,
      resolverAddress: isSet(object.resolver_address)
        ? Address.fromJSON(object.resolver_address)
        : undefined,
      resolveTimeout: isSet(object.resolve_timeout)
        ? globalThis.Number(object.resolve_timeout)
        : 0,
    };
  },

  toJSON(message: EscrowSettlementParams): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contract_address = Address.toJSON(message.contractAddress);
    }
    if (message.resolverAddress !== undefined) {
      obj.resolver_address = Address.toJSON(message.resolverAddress);
    }
    if (message.resolveTimeout !== undefined) {
      obj.resolve_timeout = Math.round(message.resolveTimeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EscrowSettlementParams>, I>>(
    base?: I,
  ): EscrowSettlementParams {
    return EscrowSettlementParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EscrowSettlementParams>, I>>(
    object: I,
  ): EscrowSettlementParams {
    const message = createBaseEscrowSettlementParams();
    message.contractAddress =
      object.contractAddress !== undefined && object.contractAddress !== null
        ? Address.fromPartial(object.contractAddress)
        : undefined;
    message.resolverAddress =
      object.resolverAddress !== undefined && object.resolverAddress !== null
        ? Address.fromPartial(object.resolverAddress)
        : undefined;
    message.resolveTimeout = object.resolveTimeout ?? 0;
    return message;
  },
};

function createBaseHtlcSettlementParams(): HtlcSettlementParams {
  return {
    contractAddress: undefined,
    resolverAddress: undefined,
    resolveTimeout: 0,
  };
}

export const HtlcSettlementParams = {
  fromJSON(object: any): HtlcSettlementParams {
    return {
      contractAddress: isSet(object.contract_address)
        ? Address.fromJSON(object.contract_address)
        : undefined,
      resolverAddress: isSet(object.resolver_address)
        ? Address.fromJSON(object.resolver_address)
        : undefined,
      resolveTimeout: isSet(object.resolve_timeout)
        ? globalThis.Number(object.resolve_timeout)
        : 0,
    };
  },

  toJSON(message: HtlcSettlementParams): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contract_address = Address.toJSON(message.contractAddress);
    }
    if (message.resolverAddress !== undefined) {
      obj.resolver_address = Address.toJSON(message.resolverAddress);
    }
    if (message.resolveTimeout !== undefined) {
      obj.resolve_timeout = Math.round(message.resolveTimeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HtlcSettlementParams>, I>>(
    base?: I,
  ): HtlcSettlementParams {
    return HtlcSettlementParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HtlcSettlementParams>, I>>(
    object: I,
  ): HtlcSettlementParams {
    const message = createBaseHtlcSettlementParams();
    message.contractAddress =
      object.contractAddress !== undefined && object.contractAddress !== null
        ? Address.fromPartial(object.contractAddress)
        : undefined;
    message.resolverAddress =
      object.resolverAddress !== undefined && object.resolverAddress !== null
        ? Address.fromPartial(object.resolverAddress)
        : undefined;
    message.resolveTimeout = object.resolveTimeout ?? 0;
    return message;
  },
};

function createBaseQuoteRequest(): QuoteRequest {
  return {
    offerAssetAddress: undefined,
    askAssetAddress: undefined,
    amount: undefined,
    referrerAddress: undefined,
    referrerFeeBps: 0,
    settlementMethods: [],
    settlementParams: undefined,
  };
}

export const QuoteRequest = {
  fromJSON(object: any): QuoteRequest {
    return {
      offerAssetAddress: isSet(object.offer_asset_address)
        ? Address.fromJSON(object.offer_asset_address)
        : undefined,
      askAssetAddress: isSet(object.ask_asset_address)
        ? Address.fromJSON(object.ask_asset_address)
        : undefined,
      amount: isSet(object.amount)
        ? QuoteRequest_AmountOneOf.fromJSON(object.amount)
        : undefined,
      referrerAddress: isSet(object.referrer_address)
        ? Address.fromJSON(object.referrer_address)
        : undefined,
      referrerFeeBps: isSet(object.referrer_fee_bps)
        ? globalThis.Number(object.referrer_fee_bps)
        : 0,
      settlementMethods: globalThis.Array.isArray(object?.settlement_methods)
        ? object.settlement_methods.map((e: any) => settlementMethodFromJSON(e))
        : [],
      settlementParams: isSet(object.settlement_params)
        ? RequestSettlementParams.fromJSON(object.settlement_params)
        : undefined,
    };
  },

  toJSON(message: QuoteRequest): unknown {
    const obj: any = {};
    if (message.offerAssetAddress !== undefined) {
      obj.offer_asset_address = Address.toJSON(message.offerAssetAddress);
    }
    if (message.askAssetAddress !== undefined) {
      obj.ask_asset_address = Address.toJSON(message.askAssetAddress);
    }
    if (message.amount !== undefined) {
      obj.amount = QuoteRequest_AmountOneOf.toJSON(message.amount);
    }
    if (message.referrerAddress !== undefined) {
      obj.referrer_address = Address.toJSON(message.referrerAddress);
    }
    if (message.referrerFeeBps !== undefined) {
      obj.referrer_fee_bps = Math.round(message.referrerFeeBps);
    }
    if (message.settlementMethods?.length) {
      obj.settlement_methods = message.settlementMethods.map((e) =>
        settlementMethodToJSON(e),
      );
    }
    if (message.settlementParams !== undefined) {
      obj.settlement_params = RequestSettlementParams.toJSON(
        message.settlementParams,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteRequest>, I>>(
    base?: I,
  ): QuoteRequest {
    return QuoteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteRequest>, I>>(
    object: I,
  ): QuoteRequest {
    const message = createBaseQuoteRequest();
    message.offerAssetAddress =
      object.offerAssetAddress !== undefined &&
      object.offerAssetAddress !== null
        ? Address.fromPartial(object.offerAssetAddress)
        : undefined;
    message.askAssetAddress =
      object.askAssetAddress !== undefined && object.askAssetAddress !== null
        ? Address.fromPartial(object.askAssetAddress)
        : undefined;
    message.amount =
      object.amount !== undefined && object.amount !== null
        ? QuoteRequest_AmountOneOf.fromPartial(object.amount)
        : undefined;
    message.referrerAddress =
      object.referrerAddress !== undefined && object.referrerAddress !== null
        ? Address.fromPartial(object.referrerAddress)
        : undefined;
    message.referrerFeeBps = object.referrerFeeBps ?? 0;
    message.settlementMethods = object.settlementMethods?.map((e) => e) || [];
    message.settlementParams =
      object.settlementParams !== undefined && object.settlementParams !== null
        ? RequestSettlementParams.fromPartial(object.settlementParams)
        : undefined;
    return message;
  },
};

function createBaseQuoteRequest_AmountOneOf(): QuoteRequest_AmountOneOf {
  return { offerUnits: undefined, askUnits: undefined };
}

export const QuoteRequest_AmountOneOf = {
  fromJSON(object: any): QuoteRequest_AmountOneOf {
    return {
      offerUnits: isSet(object.offer_units)
        ? globalThis.String(object.offer_units)
        : undefined,
      askUnits: isSet(object.ask_units)
        ? globalThis.String(object.ask_units)
        : undefined,
    };
  },

  toJSON(message: QuoteRequest_AmountOneOf): unknown {
    const obj: any = {};
    if (message.offerUnits !== undefined) {
      obj.offer_units = message.offerUnits;
    }
    if (message.askUnits !== undefined) {
      obj.ask_units = message.askUnits;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteRequest_AmountOneOf>, I>>(
    base?: I,
  ): QuoteRequest_AmountOneOf {
    return QuoteRequest_AmountOneOf.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteRequest_AmountOneOf>, I>>(
    object: I,
  ): QuoteRequest_AmountOneOf {
    const message = createBaseQuoteRequest_AmountOneOf();
    message.offerUnits = object.offerUnits ?? undefined;
    message.askUnits = object.askUnits ?? undefined;
    return message;
  },
};

function createBaseQuote(): Quote {
  return {
    quoteId: "",
    resolverId: "",
    resolverName: "",
    offerAssetAddress: undefined,
    askAssetAddress: undefined,
    offerUnits: "",
    askUnits: "",
    referrerAddress: undefined,
    referrerFeeUnits: "",
    protocolFeeUnits: "",
    quoteTimestamp: 0,
    tradeStartDeadline: 0,
    gasBudget: "",
    params: undefined,
  };
}

export const Quote = {
  fromJSON(object: any): Quote {
    return {
      quoteId: isSet(object.quote_id) ? globalThis.String(object.quote_id) : "",
      resolverId: isSet(object.resolver_id)
        ? globalThis.String(object.resolver_id)
        : "",
      resolverName: isSet(object.resolver_name)
        ? globalThis.String(object.resolver_name)
        : "",
      offerAssetAddress: isSet(object.offer_asset_address)
        ? Address.fromJSON(object.offer_asset_address)
        : undefined,
      askAssetAddress: isSet(object.ask_asset_address)
        ? Address.fromJSON(object.ask_asset_address)
        : undefined,
      offerUnits: isSet(object.offer_units)
        ? globalThis.String(object.offer_units)
        : "",
      askUnits: isSet(object.ask_units)
        ? globalThis.String(object.ask_units)
        : "",
      referrerAddress: isSet(object.referrer_address)
        ? Address.fromJSON(object.referrer_address)
        : undefined,
      referrerFeeUnits: isSet(object.referrer_fee_units)
        ? globalThis.String(object.referrer_fee_units)
        : "",
      protocolFeeUnits: isSet(object.protocol_fee_units)
        ? globalThis.String(object.protocol_fee_units)
        : "",
      quoteTimestamp: isSet(object.quote_timestamp)
        ? globalThis.Number(object.quote_timestamp)
        : 0,
      tradeStartDeadline: isSet(object.trade_start_deadline)
        ? globalThis.Number(object.trade_start_deadline)
        : 0,
      gasBudget: isSet(object.gas_budget)
        ? globalThis.String(object.gas_budget)
        : "",
      params: isSet(object.params)
        ? Quote_ParamsOneOf.fromJSON(object.params)
        : undefined,
    };
  },

  toJSON(message: Quote): unknown {
    const obj: any = {};
    if (message.quoteId !== undefined) {
      obj.quote_id = message.quoteId;
    }
    if (message.resolverId !== undefined) {
      obj.resolver_id = message.resolverId;
    }
    if (message.resolverName !== undefined) {
      obj.resolver_name = message.resolverName;
    }
    if (message.offerAssetAddress !== undefined) {
      obj.offer_asset_address = Address.toJSON(message.offerAssetAddress);
    }
    if (message.askAssetAddress !== undefined) {
      obj.ask_asset_address = Address.toJSON(message.askAssetAddress);
    }
    if (message.offerUnits !== undefined) {
      obj.offer_units = message.offerUnits;
    }
    if (message.askUnits !== undefined) {
      obj.ask_units = message.askUnits;
    }
    if (message.referrerAddress !== undefined) {
      obj.referrer_address = Address.toJSON(message.referrerAddress);
    }
    if (message.referrerFeeUnits !== undefined) {
      obj.referrer_fee_units = message.referrerFeeUnits;
    }
    if (message.protocolFeeUnits !== undefined) {
      obj.protocol_fee_units = message.protocolFeeUnits;
    }
    if (message.quoteTimestamp !== undefined) {
      obj.quote_timestamp = Math.round(message.quoteTimestamp);
    }
    if (message.tradeStartDeadline !== undefined) {
      obj.trade_start_deadline = Math.round(message.tradeStartDeadline);
    }
    if (message.gasBudget !== undefined) {
      obj.gas_budget = message.gasBudget;
    }
    if (message.params !== undefined) {
      obj.params = Quote_ParamsOneOf.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Quote>, I>>(base?: I): Quote {
    return Quote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Quote>, I>>(object: I): Quote {
    const message = createBaseQuote();
    message.quoteId = object.quoteId ?? "";
    message.resolverId = object.resolverId ?? "";
    message.resolverName = object.resolverName ?? "";
    message.offerAssetAddress =
      object.offerAssetAddress !== undefined &&
      object.offerAssetAddress !== null
        ? Address.fromPartial(object.offerAssetAddress)
        : undefined;
    message.askAssetAddress =
      object.askAssetAddress !== undefined && object.askAssetAddress !== null
        ? Address.fromPartial(object.askAssetAddress)
        : undefined;
    message.offerUnits = object.offerUnits ?? "";
    message.askUnits = object.askUnits ?? "";
    message.referrerAddress =
      object.referrerAddress !== undefined && object.referrerAddress !== null
        ? Address.fromPartial(object.referrerAddress)
        : undefined;
    message.referrerFeeUnits = object.referrerFeeUnits ?? "";
    message.protocolFeeUnits = object.protocolFeeUnits ?? "";
    message.quoteTimestamp = object.quoteTimestamp ?? 0;
    message.tradeStartDeadline = object.tradeStartDeadline ?? 0;
    message.gasBudget = object.gasBudget ?? "";
    message.params =
      object.params !== undefined && object.params !== null
        ? Quote_ParamsOneOf.fromPartial(object.params)
        : undefined;
    return message;
  },
};

function createBaseQuote_ParamsOneOf(): Quote_ParamsOneOf {
  return { swap: undefined, escrow: undefined, htlc: undefined };
}

export const Quote_ParamsOneOf = {
  fromJSON(object: any): Quote_ParamsOneOf {
    return {
      swap: isSet(object.swap)
        ? SwapSettlementParams.fromJSON(object.swap)
        : undefined,
      escrow: isSet(object.escrow)
        ? EscrowSettlementParams.fromJSON(object.escrow)
        : undefined,
      htlc: isSet(object.htlc)
        ? HtlcSettlementParams.fromJSON(object.htlc)
        : undefined,
    };
  },

  toJSON(message: Quote_ParamsOneOf): unknown {
    const obj: any = {};
    if (message.swap !== undefined) {
      obj.swap = SwapSettlementParams.toJSON(message.swap);
    }
    if (message.escrow !== undefined) {
      obj.escrow = EscrowSettlementParams.toJSON(message.escrow);
    }
    if (message.htlc !== undefined) {
      obj.htlc = HtlcSettlementParams.toJSON(message.htlc);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Quote_ParamsOneOf>, I>>(
    base?: I,
  ): Quote_ParamsOneOf {
    return Quote_ParamsOneOf.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Quote_ParamsOneOf>, I>>(
    object: I,
  ): Quote_ParamsOneOf {
    const message = createBaseQuote_ParamsOneOf();
    message.swap =
      object.swap !== undefined && object.swap !== null
        ? SwapSettlementParams.fromPartial(object.swap)
        : undefined;
    message.escrow =
      object.escrow !== undefined && object.escrow !== null
        ? EscrowSettlementParams.fromPartial(object.escrow)
        : undefined;
    message.htlc =
      object.htlc !== undefined && object.htlc !== null
        ? HtlcSettlementParams.fromPartial(object.htlc)
        : undefined;
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
