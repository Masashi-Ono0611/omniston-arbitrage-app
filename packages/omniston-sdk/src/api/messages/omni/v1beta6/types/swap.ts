// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: omni/v1beta6/types/swap.proto

/* eslint-disable */
import { Address } from "./common";

export const protobufPackage = "omni.v1beta6";

/** Represents route of swapping assets: `TON -> USDT`, `TON -> USDC -> USDT`, etc. */
export interface SwapRoute {
  steps: SwapStep[];
  gasBudget: string;
}

/** Represents a single step in a route: `TON -> USDC -> USDT` route consists of `TON -> USDC` & `USDC -> USDT` steps. */
export interface SwapStep {
  offerAssetAddress: Address | undefined;
  askAssetAddress: Address | undefined;
  chunks: SwapChunk[];
}

/** Represents a single swap tx in a step: `TON -> USDT` swap might consist of two chunks utilizing different protocols. */
export interface SwapChunk {
  protocol: string;
  offerAmount: string;
  askAmount: string;
  extraVersion: number;
  extra: number[];
}

function createBaseSwapRoute(): SwapRoute {
  return { steps: [], gasBudget: "" };
}

export const SwapRoute = {
  fromJSON(object: any): SwapRoute {
    return {
      steps: globalThis.Array.isArray(object?.steps)
        ? object.steps.map((e: any) => SwapStep.fromJSON(e))
        : [],
      gasBudget: isSet(object.gas_budget)
        ? globalThis.String(object.gas_budget)
        : "",
    };
  },

  toJSON(message: SwapRoute): unknown {
    const obj: any = {};
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => SwapStep.toJSON(e));
    }
    if (message.gasBudget !== undefined) {
      obj.gas_budget = message.gasBudget;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapRoute>, I>>(base?: I): SwapRoute {
    return SwapRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapRoute>, I>>(
    object: I,
  ): SwapRoute {
    const message = createBaseSwapRoute();
    message.steps = object.steps?.map((e) => SwapStep.fromPartial(e)) || [];
    message.gasBudget = object.gasBudget ?? "";
    return message;
  },
};

function createBaseSwapStep(): SwapStep {
  return {
    offerAssetAddress: undefined,
    askAssetAddress: undefined,
    chunks: [],
  };
}

export const SwapStep = {
  fromJSON(object: any): SwapStep {
    return {
      offerAssetAddress: isSet(object.offer_asset_address)
        ? Address.fromJSON(object.offer_asset_address)
        : undefined,
      askAssetAddress: isSet(object.ask_asset_address)
        ? Address.fromJSON(object.ask_asset_address)
        : undefined,
      chunks: globalThis.Array.isArray(object?.chunks)
        ? object.chunks.map((e: any) => SwapChunk.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SwapStep): unknown {
    const obj: any = {};
    if (message.offerAssetAddress !== undefined) {
      obj.offer_asset_address = Address.toJSON(message.offerAssetAddress);
    }
    if (message.askAssetAddress !== undefined) {
      obj.ask_asset_address = Address.toJSON(message.askAssetAddress);
    }
    if (message.chunks?.length) {
      obj.chunks = message.chunks.map((e) => SwapChunk.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapStep>, I>>(base?: I): SwapStep {
    return SwapStep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapStep>, I>>(object: I): SwapStep {
    const message = createBaseSwapStep();
    message.offerAssetAddress =
      object.offerAssetAddress !== undefined &&
      object.offerAssetAddress !== null
        ? Address.fromPartial(object.offerAssetAddress)
        : undefined;
    message.askAssetAddress =
      object.askAssetAddress !== undefined && object.askAssetAddress !== null
        ? Address.fromPartial(object.askAssetAddress)
        : undefined;
    message.chunks = object.chunks?.map((e) => SwapChunk.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSwapChunk(): SwapChunk {
  return {
    protocol: "",
    offerAmount: "",
    askAmount: "",
    extraVersion: 0,
    extra: [],
  };
}

export const SwapChunk = {
  fromJSON(object: any): SwapChunk {
    return {
      protocol: isSet(object.protocol)
        ? globalThis.String(object.protocol)
        : "",
      offerAmount: isSet(object.offer_amount)
        ? globalThis.String(object.offer_amount)
        : "",
      askAmount: isSet(object.ask_amount)
        ? globalThis.String(object.ask_amount)
        : "",
      extraVersion: isSet(object.extra_version)
        ? globalThis.Number(object.extra_version)
        : 0,
      extra: globalThis.Array.isArray(object?.extra)
        ? object.extra.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: SwapChunk): unknown {
    const obj: any = {};
    if (message.protocol !== undefined) {
      obj.protocol = message.protocol;
    }
    if (message.offerAmount !== undefined) {
      obj.offer_amount = message.offerAmount;
    }
    if (message.askAmount !== undefined) {
      obj.ask_amount = message.askAmount;
    }
    if (message.extraVersion !== undefined) {
      obj.extra_version = Math.round(message.extraVersion);
    }
    if (message.extra?.length) {
      obj.extra = message.extra.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapChunk>, I>>(base?: I): SwapChunk {
    return SwapChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapChunk>, I>>(
    object: I,
  ): SwapChunk {
    const message = createBaseSwapChunk();
    message.protocol = object.protocol ?? "";
    message.offerAmount = object.offerAmount ?? "";
    message.askAmount = object.askAmount ?? "";
    message.extraVersion = object.extraVersion ?? 0;
    message.extra = object.extra?.map((e) => e) || [];
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
