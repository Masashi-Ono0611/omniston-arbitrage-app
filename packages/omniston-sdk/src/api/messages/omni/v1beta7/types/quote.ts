// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: omni/v1beta7/types/quote.proto

/* eslint-disable */
import {
  Address,
  SettlementMethod,
  settlementMethodFromJSON,
  settlementMethodToJSON,
} from "./common";
import { SwapRoute } from "./swap";

export const protobufPackage = "omni.v1beta7";

export const GaslessSettlement = {
  /** GASLESS_SETTLEMENT_PROHIBITED - Gasless settlement either unsupported or prohibited by trader. */
  GASLESS_SETTLEMENT_PROHIBITED: "GASLESS_SETTLEMENT_PROHIBITED",
  /** GASLESS_SETTLEMENT_POSSIBLE - Gasless possible. */
  GASLESS_SETTLEMENT_POSSIBLE: "GASLESS_SETTLEMENT_POSSIBLE",
  /** GASLESS_SETTLEMENT_REQUIRED - Gasless settlement required. */
  GASLESS_SETTLEMENT_REQUIRED: "GASLESS_SETTLEMENT_REQUIRED",
  UNRECOGNIZED: "UNRECOGNIZED",
} as const;

export type GaslessSettlement =
  (typeof GaslessSettlement)[keyof typeof GaslessSettlement];

export namespace GaslessSettlement {
  export type GASLESS_SETTLEMENT_PROHIBITED =
    typeof GaslessSettlement.GASLESS_SETTLEMENT_PROHIBITED;
  export type GASLESS_SETTLEMENT_POSSIBLE =
    typeof GaslessSettlement.GASLESS_SETTLEMENT_POSSIBLE;
  export type GASLESS_SETTLEMENT_REQUIRED =
    typeof GaslessSettlement.GASLESS_SETTLEMENT_REQUIRED;
  export type UNRECOGNIZED = typeof GaslessSettlement.UNRECOGNIZED;
}

export function gaslessSettlementFromJSON(object: any): GaslessSettlement {
  switch (object) {
    case 0:
    case "GASLESS_SETTLEMENT_PROHIBITED":
      return GaslessSettlement.GASLESS_SETTLEMENT_PROHIBITED;
    case 1:
    case "GASLESS_SETTLEMENT_POSSIBLE":
      return GaslessSettlement.GASLESS_SETTLEMENT_POSSIBLE;
    case 2:
    case "GASLESS_SETTLEMENT_REQUIRED":
      return GaslessSettlement.GASLESS_SETTLEMENT_REQUIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GaslessSettlement.UNRECOGNIZED;
  }
}

export function gaslessSettlementToJSON(object: GaslessSettlement): number {
  switch (object) {
    case GaslessSettlement.GASLESS_SETTLEMENT_PROHIBITED:
      return 0;
    case GaslessSettlement.GASLESS_SETTLEMENT_POSSIBLE:
      return 1;
    case GaslessSettlement.GASLESS_SETTLEMENT_REQUIRED:
      return 2;
    case GaslessSettlement.UNRECOGNIZED:
    default:
      return -1;
  }
}

/**
 * Additional parameters of RFQ related to settlement.
 *
 * Some parameters might be valid only in a subset of settlement methods on a subset of supported blockchains.
 * These parameters might be omitted if corresponding settlement methods won't be used.
 */
export interface RequestSettlementParams {
  /** Max price slippage in basis points (0.01%). */
  maxPriceSlippageBps: number;
  /**
   * Max number of outgoing messages supported by the wallet.
   *
   * For TON blockchain defaults to 4 if omitted.
   */
  maxOutgoingMessages: number;
  /** Gasless settlement parameters. */
  gaslessSettlement: GaslessSettlement;
}

/** Settlement parameters specific to `SWAP` settlement method. */
export interface SwapSettlementParams {
  routes: SwapRoute[];
  /**
   * TODO: Add a separate destination for trade tracking and fee collection
   * Filled by Omniston service
   */
  minAskAmount: string;
  recommendedMinAskAmount: string;
  recommendedSlippageBps: number;
}

/**
 * Settlement parameters specific to `ESCROW` settlement method.
 *
 * **UNSTABLE:** This is unstable API, it's subject to backward-incompatible changes.
 */
export interface EscrowSettlementParams {
  /** Address of escrow contract that enforces the swap. */
  contractAddress: Address | undefined;
  /** Address of the resolver. */
  resolverAddress: Address | undefined;
  /**
   * Duration in seconds after the deposit of bid asset to complete the trade.
   * The trader can return the deposit as soon as the timeout elapses.
   */
  resolveTimeout: number;
  /** Indicates whether a gasless order should be created for the quote. */
  gasless: boolean;
}

/**
 * Settlement parameters specific to `HTLC` settlement method.
 *
 * **UNSTABLE:** This is unstable API, it's subject to backward-incompatible changes.
 */
export interface HtlcSettlementParams {
  /** Address of htlc contract that enforces the swap. */
  contractAddress: Address | undefined;
  /** Address of the resolver. */
  resolverAddress: Address | undefined;
  /**
   * Duration in seconds after the deposit of bid asset to redeem the deposit by resolver.
   * The trader can return the deposit as soon as the timeout elapses.
   */
  resolveTimeout: number;
}

/** A request for quote (RFQ) sent by the trader */
export interface QuoteRequest {
  /** Blockchain-specific address of bid asset. */
  bidAssetAddress: Address | undefined;
  /** Blockchain-specific address of ask asset. */
  askAssetAddress: Address | undefined;
  amount: QuoteRequest_AmountOneOf | undefined;
  /** The address of referrer that will receive the fees. */
  referrerAddress: Address | undefined;
  /** The amount of fees required by the referrer in basis points (1/10000 or 0.01%) */
  referrerFeeBps: number;
  /**
   * Supported methods of swap settlement.
   * The protocol limits settlement methods in quotes to specified methods.
   * Different combinations of bid & ask chains might support different methods.
   */
  settlementMethods: SettlementMethod[];
  /** Additional parameters of request related to settlement. */
  settlementParams: RequestSettlementParams | undefined;
}

/** Either the amount of bid asset or ask asset. */
export interface QuoteRequest_AmountOneOf {
  /** The amount of bid asset the trader wants to pay, including all fees. */
  bidUnits?: string | undefined;
  /** The amount of ask asset the trader wants to get after all fees. */
  askUnits?: string | undefined;
}

export interface Quote {
  /** ID of the quote generated by the platform */
  quoteId: string;
  /** id of the resolver */
  resolverId: string;
  /** Name of the resolver */
  resolverName: string;
  /** Blockchain-specific address of bid asset. */
  bidAssetAddress: Address | undefined;
  /** Blockchain-specific address of ask asset. */
  askAssetAddress: Address | undefined;
  /** The amount of bid asset the trader must pay, including all fees. */
  bidUnits: string;
  /** The amount of ask asset the trader will get after all fees. */
  askUnits: string;
  /** The address of referrer that will receive the fees. */
  referrerAddress: Address | undefined;
  /** The asset of the fees that the referrer will get (the amount is specified in  `referrer_fee_units`). */
  referrerFeeAsset: Address | undefined;
  /** The amount of fees that the referrer will get (in units of the asset specified in `referrer_fee_asset`). */
  referrerFeeUnits: string;
  /** The asset of the fees charged by the protocol (the amount is specified in  `protocol_fee_units`). */
  protocolFeeAsset: Address | undefined;
  /** The amount of fees charged by the protocol (in units of the asset specified in `protocol_fee_asset`). */
  protocolFeeUnits: string;
  /** The timestamp (UTC seconds) of Quote sent by resolver. */
  quoteTimestamp: number;
  /**
   * Max timestamp (UTC seconds) of start of the trade.
   *
   * The start of the trade is defined as the reception of bid asset by the corresponding smart contract.
   * The resolver may still settle the trades started after this deadline has passed at own discretion.
   */
  tradeStartDeadline: number;
  params: Quote_ParamsOneOf | undefined;
  /**
   * Total gas budget required to perform the trade.
   *
   * This field if filled by Omniston service, resolvers may omit this field when generating the quote.
   */
  gasBudget: string;
  /**
   * Estimated amount of gas units that will be spent to perform the trade.
   *
   * This field if filled by Omniston service, resolvers may omit this field when generating the quote.
   */
  estimatedGasConsumption: string;
}

/** Additional parameters specific to settlement method. */
export interface Quote_ParamsOneOf {
  swap?: SwapSettlementParams | undefined;
  escrow?: EscrowSettlementParams | undefined;
  htlc?: HtlcSettlementParams | undefined;
}

function createBaseRequestSettlementParams(): RequestSettlementParams {
  return {
    maxPriceSlippageBps: 0,
    maxOutgoingMessages: 0,
    gaslessSettlement: GaslessSettlement.GASLESS_SETTLEMENT_PROHIBITED,
  };
}

export const RequestSettlementParams = {
  fromJSON(object: any): RequestSettlementParams {
    return {
      maxPriceSlippageBps: isSet(object.max_price_slippage_bps)
        ? globalThis.Number(object.max_price_slippage_bps)
        : 0,
      maxOutgoingMessages: isSet(object.max_outgoing_messages)
        ? globalThis.Number(object.max_outgoing_messages)
        : 0,
      gaslessSettlement: isSet(object.gasless_settlement)
        ? gaslessSettlementFromJSON(object.gasless_settlement)
        : GaslessSettlement.GASLESS_SETTLEMENT_PROHIBITED,
    };
  },

  toJSON(message: RequestSettlementParams): unknown {
    const obj: any = {};
    if (message.maxPriceSlippageBps !== undefined) {
      obj.max_price_slippage_bps = Math.round(message.maxPriceSlippageBps);
    }
    if (message.maxOutgoingMessages !== undefined) {
      obj.max_outgoing_messages = Math.round(message.maxOutgoingMessages);
    }
    if (message.gaslessSettlement !== undefined) {
      obj.gasless_settlement = gaslessSettlementToJSON(
        message.gaslessSettlement,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestSettlementParams>, I>>(
    base?: I,
  ): RequestSettlementParams {
    return RequestSettlementParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestSettlementParams>, I>>(
    object: I,
  ): RequestSettlementParams {
    const message = createBaseRequestSettlementParams();
    message.maxPriceSlippageBps = object.maxPriceSlippageBps ?? 0;
    message.maxOutgoingMessages = object.maxOutgoingMessages ?? 0;
    message.gaslessSettlement =
      object.gaslessSettlement ??
      GaslessSettlement.GASLESS_SETTLEMENT_PROHIBITED;
    return message;
  },
};

function createBaseSwapSettlementParams(): SwapSettlementParams {
  return {
    routes: [],
    minAskAmount: "",
    recommendedMinAskAmount: "",
    recommendedSlippageBps: 0,
  };
}

export const SwapSettlementParams = {
  fromJSON(object: any): SwapSettlementParams {
    return {
      routes: globalThis.Array.isArray(object?.routes)
        ? object.routes.map((e: any) => SwapRoute.fromJSON(e))
        : [],
      minAskAmount: isSet(object.min_ask_amount)
        ? globalThis.String(object.min_ask_amount)
        : "",
      recommendedMinAskAmount: isSet(object.recommended_min_ask_amount)
        ? globalThis.String(object.recommended_min_ask_amount)
        : "",
      recommendedSlippageBps: isSet(object.recommended_slippage_bps)
        ? globalThis.Number(object.recommended_slippage_bps)
        : 0,
    };
  },

  toJSON(message: SwapSettlementParams): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => SwapRoute.toJSON(e));
    }
    if (message.minAskAmount !== undefined) {
      obj.min_ask_amount = message.minAskAmount;
    }
    if (message.recommendedMinAskAmount !== undefined) {
      obj.recommended_min_ask_amount = message.recommendedMinAskAmount;
    }
    if (message.recommendedSlippageBps !== undefined) {
      obj.recommended_slippage_bps = Math.round(message.recommendedSlippageBps);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapSettlementParams>, I>>(
    base?: I,
  ): SwapSettlementParams {
    return SwapSettlementParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapSettlementParams>, I>>(
    object: I,
  ): SwapSettlementParams {
    const message = createBaseSwapSettlementParams();
    message.routes = object.routes?.map((e) => SwapRoute.fromPartial(e)) || [];
    message.minAskAmount = object.minAskAmount ?? "";
    message.recommendedMinAskAmount = object.recommendedMinAskAmount ?? "";
    message.recommendedSlippageBps = object.recommendedSlippageBps ?? 0;
    return message;
  },
};

function createBaseEscrowSettlementParams(): EscrowSettlementParams {
  return {
    contractAddress: undefined,
    resolverAddress: undefined,
    resolveTimeout: 0,
    gasless: false,
  };
}

export const EscrowSettlementParams = {
  fromJSON(object: any): EscrowSettlementParams {
    return {
      contractAddress: isSet(object.contract_address)
        ? Address.fromJSON(object.contract_address)
        : undefined,
      resolverAddress: isSet(object.resolver_address)
        ? Address.fromJSON(object.resolver_address)
        : undefined,
      resolveTimeout: isSet(object.resolve_timeout)
        ? globalThis.Number(object.resolve_timeout)
        : 0,
      gasless: isSet(object.gasless)
        ? globalThis.Boolean(object.gasless)
        : false,
    };
  },

  toJSON(message: EscrowSettlementParams): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contract_address = Address.toJSON(message.contractAddress);
    }
    if (message.resolverAddress !== undefined) {
      obj.resolver_address = Address.toJSON(message.resolverAddress);
    }
    if (message.resolveTimeout !== undefined) {
      obj.resolve_timeout = Math.round(message.resolveTimeout);
    }
    if (message.gasless !== undefined) {
      obj.gasless = message.gasless;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EscrowSettlementParams>, I>>(
    base?: I,
  ): EscrowSettlementParams {
    return EscrowSettlementParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EscrowSettlementParams>, I>>(
    object: I,
  ): EscrowSettlementParams {
    const message = createBaseEscrowSettlementParams();
    message.contractAddress =
      object.contractAddress !== undefined && object.contractAddress !== null
        ? Address.fromPartial(object.contractAddress)
        : undefined;
    message.resolverAddress =
      object.resolverAddress !== undefined && object.resolverAddress !== null
        ? Address.fromPartial(object.resolverAddress)
        : undefined;
    message.resolveTimeout = object.resolveTimeout ?? 0;
    message.gasless = object.gasless ?? false;
    return message;
  },
};

function createBaseHtlcSettlementParams(): HtlcSettlementParams {
  return {
    contractAddress: undefined,
    resolverAddress: undefined,
    resolveTimeout: 0,
  };
}

export const HtlcSettlementParams = {
  fromJSON(object: any): HtlcSettlementParams {
    return {
      contractAddress: isSet(object.contract_address)
        ? Address.fromJSON(object.contract_address)
        : undefined,
      resolverAddress: isSet(object.resolver_address)
        ? Address.fromJSON(object.resolver_address)
        : undefined,
      resolveTimeout: isSet(object.resolve_timeout)
        ? globalThis.Number(object.resolve_timeout)
        : 0,
    };
  },

  toJSON(message: HtlcSettlementParams): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contract_address = Address.toJSON(message.contractAddress);
    }
    if (message.resolverAddress !== undefined) {
      obj.resolver_address = Address.toJSON(message.resolverAddress);
    }
    if (message.resolveTimeout !== undefined) {
      obj.resolve_timeout = Math.round(message.resolveTimeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HtlcSettlementParams>, I>>(
    base?: I,
  ): HtlcSettlementParams {
    return HtlcSettlementParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HtlcSettlementParams>, I>>(
    object: I,
  ): HtlcSettlementParams {
    const message = createBaseHtlcSettlementParams();
    message.contractAddress =
      object.contractAddress !== undefined && object.contractAddress !== null
        ? Address.fromPartial(object.contractAddress)
        : undefined;
    message.resolverAddress =
      object.resolverAddress !== undefined && object.resolverAddress !== null
        ? Address.fromPartial(object.resolverAddress)
        : undefined;
    message.resolveTimeout = object.resolveTimeout ?? 0;
    return message;
  },
};

function createBaseQuoteRequest(): QuoteRequest {
  return {
    bidAssetAddress: undefined,
    askAssetAddress: undefined,
    amount: undefined,
    referrerAddress: undefined,
    referrerFeeBps: 0,
    settlementMethods: [],
    settlementParams: undefined,
  };
}

export const QuoteRequest = {
  fromJSON(object: any): QuoteRequest {
    return {
      bidAssetAddress: isSet(object.bid_asset_address)
        ? Address.fromJSON(object.bid_asset_address)
        : undefined,
      askAssetAddress: isSet(object.ask_asset_address)
        ? Address.fromJSON(object.ask_asset_address)
        : undefined,
      amount: isSet(object.amount)
        ? QuoteRequest_AmountOneOf.fromJSON(object.amount)
        : undefined,
      referrerAddress: isSet(object.referrer_address)
        ? Address.fromJSON(object.referrer_address)
        : undefined,
      referrerFeeBps: isSet(object.referrer_fee_bps)
        ? globalThis.Number(object.referrer_fee_bps)
        : 0,
      settlementMethods: globalThis.Array.isArray(object?.settlement_methods)
        ? object.settlement_methods.map((e: any) => settlementMethodFromJSON(e))
        : [],
      settlementParams: isSet(object.settlement_params)
        ? RequestSettlementParams.fromJSON(object.settlement_params)
        : undefined,
    };
  },

  toJSON(message: QuoteRequest): unknown {
    const obj: any = {};
    if (message.bidAssetAddress !== undefined) {
      obj.bid_asset_address = Address.toJSON(message.bidAssetAddress);
    }
    if (message.askAssetAddress !== undefined) {
      obj.ask_asset_address = Address.toJSON(message.askAssetAddress);
    }
    if (message.amount !== undefined) {
      obj.amount = QuoteRequest_AmountOneOf.toJSON(message.amount);
    }
    if (message.referrerAddress !== undefined) {
      obj.referrer_address = Address.toJSON(message.referrerAddress);
    }
    if (message.referrerFeeBps !== undefined) {
      obj.referrer_fee_bps = Math.round(message.referrerFeeBps);
    }
    if (message.settlementMethods?.length) {
      obj.settlement_methods = message.settlementMethods.map((e) =>
        settlementMethodToJSON(e),
      );
    }
    if (message.settlementParams !== undefined) {
      obj.settlement_params = RequestSettlementParams.toJSON(
        message.settlementParams,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteRequest>, I>>(
    base?: I,
  ): QuoteRequest {
    return QuoteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteRequest>, I>>(
    object: I,
  ): QuoteRequest {
    const message = createBaseQuoteRequest();
    message.bidAssetAddress =
      object.bidAssetAddress !== undefined && object.bidAssetAddress !== null
        ? Address.fromPartial(object.bidAssetAddress)
        : undefined;
    message.askAssetAddress =
      object.askAssetAddress !== undefined && object.askAssetAddress !== null
        ? Address.fromPartial(object.askAssetAddress)
        : undefined;
    message.amount =
      object.amount !== undefined && object.amount !== null
        ? QuoteRequest_AmountOneOf.fromPartial(object.amount)
        : undefined;
    message.referrerAddress =
      object.referrerAddress !== undefined && object.referrerAddress !== null
        ? Address.fromPartial(object.referrerAddress)
        : undefined;
    message.referrerFeeBps = object.referrerFeeBps ?? 0;
    message.settlementMethods = object.settlementMethods?.map((e) => e) || [];
    message.settlementParams =
      object.settlementParams !== undefined && object.settlementParams !== null
        ? RequestSettlementParams.fromPartial(object.settlementParams)
        : undefined;
    return message;
  },
};

function createBaseQuoteRequest_AmountOneOf(): QuoteRequest_AmountOneOf {
  return { bidUnits: undefined, askUnits: undefined };
}

export const QuoteRequest_AmountOneOf = {
  fromJSON(object: any): QuoteRequest_AmountOneOf {
    return {
      bidUnits: isSet(object.bid_units)
        ? globalThis.String(object.bid_units)
        : undefined,
      askUnits: isSet(object.ask_units)
        ? globalThis.String(object.ask_units)
        : undefined,
    };
  },

  toJSON(message: QuoteRequest_AmountOneOf): unknown {
    const obj: any = {};
    if (message.bidUnits !== undefined) {
      obj.bid_units = message.bidUnits;
    }
    if (message.askUnits !== undefined) {
      obj.ask_units = message.askUnits;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteRequest_AmountOneOf>, I>>(
    base?: I,
  ): QuoteRequest_AmountOneOf {
    return QuoteRequest_AmountOneOf.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteRequest_AmountOneOf>, I>>(
    object: I,
  ): QuoteRequest_AmountOneOf {
    const message = createBaseQuoteRequest_AmountOneOf();
    message.bidUnits = object.bidUnits ?? undefined;
    message.askUnits = object.askUnits ?? undefined;
    return message;
  },
};

function createBaseQuote(): Quote {
  return {
    quoteId: "",
    resolverId: "",
    resolverName: "",
    bidAssetAddress: undefined,
    askAssetAddress: undefined,
    bidUnits: "",
    askUnits: "",
    referrerAddress: undefined,
    referrerFeeAsset: undefined,
    referrerFeeUnits: "",
    protocolFeeAsset: undefined,
    protocolFeeUnits: "",
    quoteTimestamp: 0,
    tradeStartDeadline: 0,
    params: undefined,
    gasBudget: "",
    estimatedGasConsumption: "",
  };
}

export const Quote = {
  fromJSON(object: any): Quote {
    return {
      quoteId: isSet(object.quote_id) ? globalThis.String(object.quote_id) : "",
      resolverId: isSet(object.resolver_id)
        ? globalThis.String(object.resolver_id)
        : "",
      resolverName: isSet(object.resolver_name)
        ? globalThis.String(object.resolver_name)
        : "",
      bidAssetAddress: isSet(object.bid_asset_address)
        ? Address.fromJSON(object.bid_asset_address)
        : undefined,
      askAssetAddress: isSet(object.ask_asset_address)
        ? Address.fromJSON(object.ask_asset_address)
        : undefined,
      bidUnits: isSet(object.bid_units)
        ? globalThis.String(object.bid_units)
        : "",
      askUnits: isSet(object.ask_units)
        ? globalThis.String(object.ask_units)
        : "",
      referrerAddress: isSet(object.referrer_address)
        ? Address.fromJSON(object.referrer_address)
        : undefined,
      referrerFeeAsset: isSet(object.referrer_fee_asset)
        ? Address.fromJSON(object.referrer_fee_asset)
        : undefined,
      referrerFeeUnits: isSet(object.referrer_fee_units)
        ? globalThis.String(object.referrer_fee_units)
        : "",
      protocolFeeAsset: isSet(object.protocol_fee_asset)
        ? Address.fromJSON(object.protocol_fee_asset)
        : undefined,
      protocolFeeUnits: isSet(object.protocol_fee_units)
        ? globalThis.String(object.protocol_fee_units)
        : "",
      quoteTimestamp: isSet(object.quote_timestamp)
        ? globalThis.Number(object.quote_timestamp)
        : 0,
      tradeStartDeadline: isSet(object.trade_start_deadline)
        ? globalThis.Number(object.trade_start_deadline)
        : 0,
      params: isSet(object.params)
        ? Quote_ParamsOneOf.fromJSON(object.params)
        : undefined,
      gasBudget: isSet(object.gas_budget)
        ? globalThis.String(object.gas_budget)
        : "",
      estimatedGasConsumption: isSet(object.estimated_gas_consumption)
        ? globalThis.String(object.estimated_gas_consumption)
        : "",
    };
  },

  toJSON(message: Quote): unknown {
    const obj: any = {};
    if (message.quoteId !== undefined) {
      obj.quote_id = message.quoteId;
    }
    if (message.resolverId !== undefined) {
      obj.resolver_id = message.resolverId;
    }
    if (message.resolverName !== undefined) {
      obj.resolver_name = message.resolverName;
    }
    if (message.bidAssetAddress !== undefined) {
      obj.bid_asset_address = Address.toJSON(message.bidAssetAddress);
    }
    if (message.askAssetAddress !== undefined) {
      obj.ask_asset_address = Address.toJSON(message.askAssetAddress);
    }
    if (message.bidUnits !== undefined) {
      obj.bid_units = message.bidUnits;
    }
    if (message.askUnits !== undefined) {
      obj.ask_units = message.askUnits;
    }
    if (message.referrerAddress !== undefined) {
      obj.referrer_address = Address.toJSON(message.referrerAddress);
    }
    if (message.referrerFeeAsset !== undefined) {
      obj.referrer_fee_asset = Address.toJSON(message.referrerFeeAsset);
    }
    if (message.referrerFeeUnits !== undefined) {
      obj.referrer_fee_units = message.referrerFeeUnits;
    }
    if (message.protocolFeeAsset !== undefined) {
      obj.protocol_fee_asset = Address.toJSON(message.protocolFeeAsset);
    }
    if (message.protocolFeeUnits !== undefined) {
      obj.protocol_fee_units = message.protocolFeeUnits;
    }
    if (message.quoteTimestamp !== undefined) {
      obj.quote_timestamp = Math.round(message.quoteTimestamp);
    }
    if (message.tradeStartDeadline !== undefined) {
      obj.trade_start_deadline = Math.round(message.tradeStartDeadline);
    }
    if (message.params !== undefined) {
      obj.params = Quote_ParamsOneOf.toJSON(message.params);
    }
    if (message.gasBudget !== undefined) {
      obj.gas_budget = message.gasBudget;
    }
    if (message.estimatedGasConsumption !== undefined) {
      obj.estimated_gas_consumption = message.estimatedGasConsumption;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Quote>, I>>(base?: I): Quote {
    return Quote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Quote>, I>>(object: I): Quote {
    const message = createBaseQuote();
    message.quoteId = object.quoteId ?? "";
    message.resolverId = object.resolverId ?? "";
    message.resolverName = object.resolverName ?? "";
    message.bidAssetAddress =
      object.bidAssetAddress !== undefined && object.bidAssetAddress !== null
        ? Address.fromPartial(object.bidAssetAddress)
        : undefined;
    message.askAssetAddress =
      object.askAssetAddress !== undefined && object.askAssetAddress !== null
        ? Address.fromPartial(object.askAssetAddress)
        : undefined;
    message.bidUnits = object.bidUnits ?? "";
    message.askUnits = object.askUnits ?? "";
    message.referrerAddress =
      object.referrerAddress !== undefined && object.referrerAddress !== null
        ? Address.fromPartial(object.referrerAddress)
        : undefined;
    message.referrerFeeAsset =
      object.referrerFeeAsset !== undefined && object.referrerFeeAsset !== null
        ? Address.fromPartial(object.referrerFeeAsset)
        : undefined;
    message.referrerFeeUnits = object.referrerFeeUnits ?? "";
    message.protocolFeeAsset =
      object.protocolFeeAsset !== undefined && object.protocolFeeAsset !== null
        ? Address.fromPartial(object.protocolFeeAsset)
        : undefined;
    message.protocolFeeUnits = object.protocolFeeUnits ?? "";
    message.quoteTimestamp = object.quoteTimestamp ?? 0;
    message.tradeStartDeadline = object.tradeStartDeadline ?? 0;
    message.params =
      object.params !== undefined && object.params !== null
        ? Quote_ParamsOneOf.fromPartial(object.params)
        : undefined;
    message.gasBudget = object.gasBudget ?? "";
    message.estimatedGasConsumption = object.estimatedGasConsumption ?? "";
    return message;
  },
};

function createBaseQuote_ParamsOneOf(): Quote_ParamsOneOf {
  return { swap: undefined, escrow: undefined, htlc: undefined };
}

export const Quote_ParamsOneOf = {
  fromJSON(object: any): Quote_ParamsOneOf {
    return {
      swap: isSet(object.swap)
        ? SwapSettlementParams.fromJSON(object.swap)
        : undefined,
      escrow: isSet(object.escrow)
        ? EscrowSettlementParams.fromJSON(object.escrow)
        : undefined,
      htlc: isSet(object.htlc)
        ? HtlcSettlementParams.fromJSON(object.htlc)
        : undefined,
    };
  },

  toJSON(message: Quote_ParamsOneOf): unknown {
    const obj: any = {};
    if (message.swap !== undefined) {
      obj.swap = SwapSettlementParams.toJSON(message.swap);
    }
    if (message.escrow !== undefined) {
      obj.escrow = EscrowSettlementParams.toJSON(message.escrow);
    }
    if (message.htlc !== undefined) {
      obj.htlc = HtlcSettlementParams.toJSON(message.htlc);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Quote_ParamsOneOf>, I>>(
    base?: I,
  ): Quote_ParamsOneOf {
    return Quote_ParamsOneOf.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Quote_ParamsOneOf>, I>>(
    object: I,
  ): Quote_ParamsOneOf {
    const message = createBaseQuote_ParamsOneOf();
    message.swap =
      object.swap !== undefined && object.swap !== null
        ? SwapSettlementParams.fromPartial(object.swap)
        : undefined;
    message.escrow =
      object.escrow !== undefined && object.escrow !== null
        ? EscrowSettlementParams.fromPartial(object.escrow)
        : undefined;
    message.htlc =
      object.htlc !== undefined && object.htlc !== null
        ? HtlcSettlementParams.fromPartial(object.htlc)
        : undefined;
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
