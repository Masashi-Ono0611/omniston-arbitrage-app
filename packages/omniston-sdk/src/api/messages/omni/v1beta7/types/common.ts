// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: omni/v1beta7/types/common.proto

/* eslint-disable */

export const protobufPackage = "omni.v1beta7";

/** The method of trade settlement. */
export const SettlementMethod = {
  /** SETTLEMENT_METHOD_SWAP - Settlement of the trade by direct swap using 3rd-party contracts. */
  SETTLEMENT_METHOD_SWAP: "SETTLEMENT_METHOD_SWAP",
  /** SETTLEMENT_METHOD_ESCROW - Settlement of the trade using a single-chain escrow contract. */
  SETTLEMENT_METHOD_ESCROW: "SETTLEMENT_METHOD_ESCROW",
  /** SETTLEMENT_METHOD_HTLC - Settlement of the trade using Hash-Time-Lock Contract. */
  SETTLEMENT_METHOD_HTLC: "SETTLEMENT_METHOD_HTLC",
  UNRECOGNIZED: "UNRECOGNIZED",
} as const;

export type SettlementMethod =
  (typeof SettlementMethod)[keyof typeof SettlementMethod];

export namespace SettlementMethod {
  export type SETTLEMENT_METHOD_SWAP =
    typeof SettlementMethod.SETTLEMENT_METHOD_SWAP;
  export type SETTLEMENT_METHOD_ESCROW =
    typeof SettlementMethod.SETTLEMENT_METHOD_ESCROW;
  export type SETTLEMENT_METHOD_HTLC =
    typeof SettlementMethod.SETTLEMENT_METHOD_HTLC;
  export type UNRECOGNIZED = typeof SettlementMethod.UNRECOGNIZED;
}

export function settlementMethodFromJSON(object: any): SettlementMethod {
  switch (object) {
    case 0:
    case "SETTLEMENT_METHOD_SWAP":
      return SettlementMethod.SETTLEMENT_METHOD_SWAP;
    case 1:
    case "SETTLEMENT_METHOD_ESCROW":
      return SettlementMethod.SETTLEMENT_METHOD_ESCROW;
    case 2:
    case "SETTLEMENT_METHOD_HTLC":
      return SettlementMethod.SETTLEMENT_METHOD_HTLC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SettlementMethod.UNRECOGNIZED;
  }
}

export function settlementMethodToJSON(object: SettlementMethod): number {
  switch (object) {
    case SettlementMethod.SETTLEMENT_METHOD_SWAP:
      return 0;
    case SettlementMethod.SETTLEMENT_METHOD_ESCROW:
      return 1;
    case SettlementMethod.SETTLEMENT_METHOD_HTLC:
      return 2;
    case SettlementMethod.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Generic address */
export interface Address {
  /**
   * Blockchain code as defined by SLIP-044.
   *
   * See: <https://github.com/satoshilabs/slips/blob/master/slip-0044.md>
   */
  blockchain: number;
  /** Blockchain-specific part of the address. */
  address: string;
}

/** The server periodically emits `KeepAlive` message to keep the connection alive. */
export interface KeepAlive {}

/**
 * Service message indicating that a request has expired.
 *
 * Used only for WebSocket API.
 */
export interface Unsubscribed {}

function createBaseAddress(): Address {
  return { blockchain: 0, address: "" };
}

export const Address = {
  fromJSON(object: any): Address {
    return {
      blockchain: isSet(object.blockchain)
        ? globalThis.Number(object.blockchain)
        : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.blockchain !== undefined) {
      obj.blockchain = Math.round(message.blockchain);
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Address>, I>>(base?: I): Address {
    return Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Address>, I>>(object: I): Address {
    const message = createBaseAddress();
    message.blockchain = object.blockchain ?? 0;
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseKeepAlive(): KeepAlive {
  return {};
}

export const KeepAlive = {
  fromJSON(_: any): KeepAlive {
    return {};
  },

  toJSON(_: KeepAlive): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<KeepAlive>, I>>(base?: I): KeepAlive {
    return KeepAlive.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeepAlive>, I>>(_: I): KeepAlive {
    const message = createBaseKeepAlive();
    return message;
  },
};

function createBaseUnsubscribed(): Unsubscribed {
  return {};
}

export const Unsubscribed = {
  fromJSON(_: any): Unsubscribed {
    return {};
  },

  toJSON(_: Unsubscribed): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Unsubscribed>, I>>(
    base?: I,
  ): Unsubscribed {
    return Unsubscribed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Unsubscribed>, I>>(
    _: I,
  ): Unsubscribed {
    const message = createBaseUnsubscribed();
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
