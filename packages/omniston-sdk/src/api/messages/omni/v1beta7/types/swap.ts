// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: omni/v1beta7/types/swap.proto

/* eslint-disable */
import { Address } from "./common";

export const protobufPackage = "omni.v1beta7";

/** Represents route of swapping assets: `TON -> USDT`, `TON -> USDC -> USDT`, etc. */
export interface SwapRoute {
  steps: SwapStep[];
}

/** Represents a single step in a route: `TON -> USDC -> USDT` route consists of `TON -> USDC` & `USDC -> USDT` steps. */
export interface SwapStep {
  bidAssetAddress: Address | undefined;
  askAssetAddress: Address | undefined;
  chunks: SwapChunk[];
}

/** Represents a single swap tx in a step: `TON -> USDT` swap might consist of two chunks utilizing different protocols. */
export interface SwapChunk {
  protocol: string;
  bidAmount: string;
  askAmount: string;
  extraVersion: number;
  extra: number[];
}

function createBaseSwapRoute(): SwapRoute {
  return { steps: [] };
}

export const SwapRoute = {
  fromJSON(object: any): SwapRoute {
    return {
      steps: globalThis.Array.isArray(object?.steps)
        ? object.steps.map((e: any) => SwapStep.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SwapRoute): unknown {
    const obj: any = {};
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => SwapStep.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapRoute>, I>>(base?: I): SwapRoute {
    return SwapRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapRoute>, I>>(
    object: I,
  ): SwapRoute {
    const message = createBaseSwapRoute();
    message.steps = object.steps?.map((e) => SwapStep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSwapStep(): SwapStep {
  return { bidAssetAddress: undefined, askAssetAddress: undefined, chunks: [] };
}

export const SwapStep = {
  fromJSON(object: any): SwapStep {
    return {
      bidAssetAddress: isSet(object.bid_asset_address)
        ? Address.fromJSON(object.bid_asset_address)
        : undefined,
      askAssetAddress: isSet(object.ask_asset_address)
        ? Address.fromJSON(object.ask_asset_address)
        : undefined,
      chunks: globalThis.Array.isArray(object?.chunks)
        ? object.chunks.map((e: any) => SwapChunk.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SwapStep): unknown {
    const obj: any = {};
    if (message.bidAssetAddress !== undefined) {
      obj.bid_asset_address = Address.toJSON(message.bidAssetAddress);
    }
    if (message.askAssetAddress !== undefined) {
      obj.ask_asset_address = Address.toJSON(message.askAssetAddress);
    }
    if (message.chunks?.length) {
      obj.chunks = message.chunks.map((e) => SwapChunk.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapStep>, I>>(base?: I): SwapStep {
    return SwapStep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapStep>, I>>(object: I): SwapStep {
    const message = createBaseSwapStep();
    message.bidAssetAddress =
      object.bidAssetAddress !== undefined && object.bidAssetAddress !== null
        ? Address.fromPartial(object.bidAssetAddress)
        : undefined;
    message.askAssetAddress =
      object.askAssetAddress !== undefined && object.askAssetAddress !== null
        ? Address.fromPartial(object.askAssetAddress)
        : undefined;
    message.chunks = object.chunks?.map((e) => SwapChunk.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSwapChunk(): SwapChunk {
  return {
    protocol: "",
    bidAmount: "",
    askAmount: "",
    extraVersion: 0,
    extra: [],
  };
}

export const SwapChunk = {
  fromJSON(object: any): SwapChunk {
    return {
      protocol: isSet(object.protocol)
        ? globalThis.String(object.protocol)
        : "",
      bidAmount: isSet(object.bid_amount)
        ? globalThis.String(object.bid_amount)
        : "",
      askAmount: isSet(object.ask_amount)
        ? globalThis.String(object.ask_amount)
        : "",
      extraVersion: isSet(object.extra_version)
        ? globalThis.Number(object.extra_version)
        : 0,
      extra: globalThis.Array.isArray(object?.extra)
        ? object.extra.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: SwapChunk): unknown {
    const obj: any = {};
    if (message.protocol !== undefined) {
      obj.protocol = message.protocol;
    }
    if (message.bidAmount !== undefined) {
      obj.bid_amount = message.bidAmount;
    }
    if (message.askAmount !== undefined) {
      obj.ask_amount = message.askAmount;
    }
    if (message.extraVersion !== undefined) {
      obj.extra_version = Math.round(message.extraVersion);
    }
    if (message.extra?.length) {
      obj.extra = message.extra.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapChunk>, I>>(base?: I): SwapChunk {
    return SwapChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapChunk>, I>>(
    object: I,
  ): SwapChunk {
    const message = createBaseSwapChunk();
    message.protocol = object.protocol ?? "";
    message.bidAmount = object.bidAmount ?? "";
    message.askAmount = object.askAmount ?? "";
    message.extraVersion = object.extraVersion ?? 0;
    message.extra = object.extra?.map((e) => e) || [];
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
